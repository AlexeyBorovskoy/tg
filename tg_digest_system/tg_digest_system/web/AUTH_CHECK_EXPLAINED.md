# Как система проверяет может ли пользователь работать

## Важный момент: система НЕ проверяет это!

Для внутреннего использования система **принимает ЛЮБОЙ Telegram ID** и разрешает доступ.

## Как это работает на практике

### Что происходит когда пользователь вводит Telegram ID:

```
1. Пользователь вводит: 499412926
   ↓
2. Система проверяет: есть ли пользователь с таким Telegram ID в БД?
   ↓
3. Если НЕТ → создаёт нового пользователя
   Если ДА → использует существующего
   ↓
4. Создаёт сессию (токен)
   ↓
5. Сохраняет в БД: user_id + session_token
   ↓
6. Устанавливает cookie в браузере
   ↓
7. ✅ ДОСТУП РАЗРЕШЁН
```

### Что НЕ проверяется:

- ❌ Нет списка разрешённых пользователей
- ❌ Нет проверки прав доступа
- ❌ Нет проверки что пользователь существует в Telegram
- ❌ Нет проверки что пользователь сотрудник фирмы

### Что проверяется:

- ✅ Есть ли валидная сессия (cookie)?
- ✅ Не истёк ли срок действия сессии?

## Примеры

### Пример 1: Новый пользователь

```
Пользователь вводит: 123456789 (не существует в БД)
   ↓
Система: создаю нового пользователя
   ↓
Результат: ✅ ДОСТУП РАЗРЕШЁН
```

### Пример 2: Существующий пользователь

```
Пользователь вводит: 499412926 (уже есть в БД)
   ↓
Система: использую существующего пользователя
   ↓
Результат: ✅ ДОСТУП РАЗРЕШЁН
```

### Пример 3: Неправильный Telegram ID

```
Пользователь вводит: 999999999999999 (нереальный ID)
   ↓
Система: создаю пользователя с этим ID
   ↓
Результат: ✅ ДОСТУП РАЗРЕШЁН (система не проверяет валидность ID)
```

## Почему так?

Для внутреннего использования в узком кругу:
- Все доверенные пользователи
- Не нужна сложная система прав
- Простота важнее безопасности
- Основная цель - изоляция данных по user_id

## Если нужна проверка доступа

Можно добавить (но для первого этапа не нужно):

### Вариант 1: Белый список Telegram ID

```python
ALLOWED_TELEGRAM_IDS = [499412926, 123456789, ...]

def check_access(telegram_id: int) -> bool:
    return telegram_id in ALLOWED_TELEGRAM_IDS
```

### Вариант 2: Проверка через Telegram Bot

```python
async def verify_telegram_user(telegram_id: int) -> bool:
    # Отправляем код в Telegram
    # Пользователь вводит код на сайте
    # Если код правильный → доступ разрешён
    pass
```

### Вариант 3: Проверка что пользователь в нужных чатах

```python
async def check_user_in_chats(telegram_id: int) -> bool:
    # Проверяем что пользователь состоит в определённых чатах
    # Если да → доступ разрешён
    pass
```

## Текущая логика (упрощённая)

```
ВХОД:
1. Пользователь вводит Telegram ID
2. Система создаёт/получает пользователя
3. Создаёт сессию
4. ✅ Доступ разрешён

ПРОВЕРКА ПРИ ЗАПРОСАХ:
1. Есть ли cookie с session_token?
2. Есть ли такая сессия в БД?
3. Не истёк ли срок?
4. Если всё ОК → используем user_id из сессии
5. Если нет → требуем вход заново
```

## Визуализация

```
┌─────────────────────────────────────┐
│  Пользователь вводит Telegram ID   │
│  499412926                          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Система: Проверяю есть ли такой   │
│  пользователь в БД?                │
└──────────────┬──────────────────────┘
               │
       ┌───────┴───────┐
       │               │
    НЕТ              ДА
       │               │
       ▼               ▼
┌──────────┐    ┌──────────┐
│ Создаю   │    │Использую │
│ нового   │    │существую-│
│          │    │щего      │
└────┬─────┘    └────┬─────┘
     │               │
     └───────┬───────┘
             │
             ▼
┌─────────────────────────────────────┐
│  Создаю сессию (токен)             │
│  Сохраняю в БД                      │
│  Устанавливаю cookie                │
└──────────────┬──────────────────────┘
               │
               ▼
        ✅ ДОСТУП РАЗРЕШЁН
```

## Итог

**Система НЕ проверяет может ли пользователь работать.**

Она просто:
1. Принимает любой Telegram ID
2. Создаёт сессию
3. Разрешает доступ

Для внутреннего использования этого достаточно.

Если нужна проверка - можно добавить белый список или проверку через Telegram, но для первого этапа это не требуется.
